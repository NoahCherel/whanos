The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
build.sh
#!/bin/bash

#minikube start

# Start Kubernetes API server
./kubernetes/kube_binary_api_server &

# Set insecure registries configuration
echo '{ "insecure-registries":    ["localhost:5000"] }' | sudo tee /etc/docker/daemon.json
sudo systemctl restart docker

# Remove and checkout Jenkins directory
sudo rm -rf jenkins/
git checkout jenkins/

# Build Jenkins Docker image
docker build . -f jenkins/Dockerfile -t whanos-jenkins

# Run Jenkins container
cd jenkins
docker run -d \
     -v $(pwd):/var/jenkins_folder \
     -v $(pwd)/../images:/images \
     --net=host \
     -v /var/run/docker.sock:/var/run/docker.sock \
     `docker images -aq | head -n 1`

# Register Jenkins Docker image in local registry
cd ..
docker exec -it `docker ps -aq | head -n 1` \
     docker run -d \
      -p 5000:5000 \
       --restart=always \
       --name whanos-registry \
       registry:2

# Access Jenkins container shell
docker exec -it `docker ps -aq | head -n 2 | tail -n +2` /bin/bash

----
images/befunge/Dockerfile.base
FROM esolang/befunge93

SHELL ["/bin/bash", "-c"]

WORKDIR /app

ONBUILD COPY ./app/ ./app/

CMD ["/root/bef", "./app/main.bf"]

----
images/befunge/Dockerfile.standalone
FROM esolang/befunge93

SHELL ["/bin/bash", "-c"]

WORKDIR /app

COPY ./app/ ./app/

CMD ["/root/bef", "./app/main.bf"]

----
images/c/Dockerfile.base
FROM gcc:13.2

SHELL ["/bin/bash", "-c"]

WORKDIR /app

ONBUILD COPY Makefile .

ONBUILD COPY ./app ./app

ONBUILD RUN make

ONBUILD RUN find . -not -name compiled-app -delete

CMD ./compiled-app
----
images/c/Dockerfile.standalone
FROM gcc:11.2

SHELL ["/bin/bash", "-c"]

WORKDIR /app

COPY Makefile .

COPY ./app ./app

RUN make

RUN find . -not -name compiled-app -delete

CMD ./compiled-app
----
images/java/Dockerfile.base
FROM openjdk:21-jdk-slim

SHELL ["/bin/bash", "-c"]

WORKDIR /app

ONBUILD COPY ./app/ ./app/

ONBUILD RUN mvn package -f app/pom.xml

ONBUILD RUN mv app/target/app.jar .

ONBUILD RUN find . -not -name app.jar -delete

CMD java -jar app.jar

----
images/java/Dockerfile.standalone
FROM maven:3.8.4-openjdk-17-slim

SHELL ["/bin/bash", "-c"]

WORKDIR /app

COPY ./app/ ./app/

RUN mvn package -f app/pom.xml

RUN mv app/target/app.jar .

RUN find . -not -name app.jar -delete

CMD java -jar app.jar
----
images/javascript/Dockerfile.base
FROM node:20.9

SHELL ["/bin/bash", "-c"]

WORKDIR /app

ONBUILD COPY package.json .

ONBUILD COPY package-lock.json .

ONBUILD COPY tsconfig.json .

ONBUILD RUN ["npm", "install"]

ONBUILD COPY app/ ./app/

CMD ["node", "."]


----
images/javascript/Dockerfile.standalone
FROM node:14.17.5

SHELL ["/bin/bash", "-c"]

WORKDIR /app

COPY package.json .

COPY package-lock.json .

RUN ["npm", "install"]

COPY app/ ./app/

CMD ["node", "."]

----
images/python/Dockerfile.base
FROM python:3.12

SHELL ["/bin/bash", "-c"]

WORKDIR /app

ONBUILD COPY requirements.txt requirements.txt

ONBUILD RUN pip install -r requirements.txt

ONBUILD COPY ./app ./app

CMD [ "python3", "-m" , "app"]
----
images/python/Dockerfile.standalone
FROM python:3.10

WORKDIR /app

COPY requirements.txt requirements.txt

RUN pip install -r requirements.txt

COPY ./app ./app

CMD [ "python3", "-m" , "app"]

----
jenkins/Dockerfile
# Use the latest LTS version of Jenkins as the base image
FROM jenkins/jenkins:lts

# Disable Jenkins setup wizard
ENV JAVA_OPTS -Djenkins.install.runSetupWizard=false

# Switch to root user for installation
USER root

# Install necessary tools and dependencies
RUN apt-get update && \
    apt-get -qy upgrade && \
    apt-get install -qy curl

# Install Docker
RUN curl -fsSL https://get.docker.com/ | sh

# Set the initial admin password
ENV PASWD=test

# Define the location for Jenkins Configuration as an environment variable
ENV CONF=/var/jenkins_folder/jenkins.yml

# Copy the list of plugins to be installed
COPY ./jenkins/plugins.txt /usr/share/plugins.txt

# Install Jenkins plugins using the plugin list
RUN jenkins-plugin-cli --plugins -f /usr/share/plugins.txt

----
jenkins/findTech.sh
#!/bin/bash

if [ -z "$1" ]; then
    echo "Usage: $0 [folder]"
    echo "folder: folder path (default: current folder)"
    exit 1
fi

declare -A LANG=(
    ["c"]="Makefile"
    ["java"]="app/pom.xml"
    ["javascript"]="package.json"
    ["python"]="requirements.txt"
    ["befunge"]="app/main.bf"
)

path="$1"
RECOGNISED=()

for i in "${!LANG[@]}"; do
    file="$path/${LANG[$i]}"

    if test -f "$file"; then
        RECOGNISED+=("$i")
    fi
done

if [ ${#RECOGNISED[@]} -eq 0 ]; then
    >&2 echo "Not found"
    exit 1
elif [ ${#RECOGNISED[@]} -gt 1 ]; then
    >&2 echo "found"
    exit 1
else
    echo "${RECOGNISED[0]}"
    exit 0
fi

----
jenkins/jenkins.yml
jenkins:
  systemMessage: "Welcome to the Whanos Jenkins Instance."
  remotingSecurity:
    enabled: true
  authorizationStrategy:
    roleBased:
      roles:
        global:
          - name: "admin"
            description: "Whanos master"
            permissions:
              - "Overall/Administer"
            entries:
              - user: "admin"
  securityRealm:
    local:
      allowsSignup: false
      users:
        - id: "admin"
          name: "Admin"
          password: ${PASWD}
tool:
  git:
    installations:
      - name: git
        home: /usr/lib/git-core/git
jobs:
  - file: /var/jenkins_folder/job_dsl.groovy
security:
  globalJobDslSecurityConfiguration:
    useScriptSecurity: false

----
jenkins/job_dsl.groovy
#!/usr/bin/env groovy

folder("Whanos base images") {
    displayName("Whanos base images")
    description("Folder for whanos base images to be stored.")
}
folder("Projects") {
    displayName("Projects")
    description("Folder for projects to be stored.")
}

freeStyleJob("Whanos base images/whanos-c") {
    steps {
        shell('docker build -t whanos-c - < /images/c/Dockerfile.base')
        shell('docker tag whanos-c localhost:5000/whanos-c')
        shell('docker push localhost:5000/whanos-c')
        shell('docker pull localhost:5000/whanos-c')
        shell('docker rmi whanos-c')
    }

    triggers {
        upstream('Build all base images')
    }
}

freeStyleJob("Whanos base images/whanos-java") {
    steps {
        shell('docker build -t whanos-java - < /images/java/Dockerfile.base')
        shell('docker tag whanos-java localhost:5000/whanos-java')
        shell('docker push localhost:5000/whanos-java')
        shell('docker pull localhost:5000/whanos-java')
        shell('docker rmi whanos-java')
    }

    triggers {
        upstream('Build all base images')
    }
}

freeStyleJob("Whanos base images/whanos-javascript") {
    steps {
        shell('docker build -t whanos-javascript - < /images/javascript/Dockerfile.base')
        shell('docker tag whanos-javascript localhost:5000/whanos-javascript')
        shell('docker push localhost:5000/whanos-javascript')
        shell('docker pull localhost:5000/whanos-javascript')
        shell('docker rmi whanos-javascript')
    }

    triggers {
        upstream('Build all base images')
    }
}

freeStyleJob("Whanos base images/whanos-befunge") {
    steps {
        shell('docker build -t whanos-befunge - < /images/befunge/Dockerfile.base')
        shell('docker tag whanos-befunge localhost:5000/whanos-befunge')
        shell('docker push localhost:5000/whanos-befunge')
        shell('docker pull localhost:5000/whanos-befunge')
        shell('docker rmi whanos-befunge')
    }

    triggers {
        upstream('Build all base images')
    }
}

freeStyleJob("Whanos base images/whanos-python") {
    steps {
        shell('docker build -t whanos-python - < /images/python/Dockerfile.base')
        shell('docker tag whanos-python localhost:5000/whanos-python')
        shell('docker push localhost:5000/whanos-python')
        shell('docker pull localhost:5000/whanos-python')
        shell('docker rmi whanos-python')
    }

    triggers {
        upstream('Build all base images')
    }
}

freeStyleJob("Build all base images") {}

freeStyleJob("link-project") {
    parameters {
        stringParam('GIT_REPOSITORY_URL', '', 'Git URL of the repository to link')
        stringParam('JOB_LABEL', '', 'Display name for the job')
    }

    steps {
        dsl {
            text('''
        freeStyleJob(\"Projects/$JOB_LABEL\") {
            scm {
                github(\"$GIT_REPOSITORY_URL\")
            }
            triggers {
                cron(\'* * * * *\')
            }
            steps {
                shell(\"/var/jenkins_folder/whanos.sh $JOB_LABEL\")
            }
            wrappers {
                preBuildCleanup()
            }
        }
            ''')
        }
    }
}
----
jenkins/whanos.sh
#!/bin/bash

echo "Starting Whanos"

# Function to get the latest commit hash
get_latest_commit_hash() {
    git log -n 1 --pretty=format:"%H"
}

# Make a copy of the Dockerfile
# Then
# Change the first line of Dockerfile
# Exemple FROM node:latest to FROM localhost:5000/whanos-node:latest
change_dockerfile() {
    local techno=$1
    cp ./Dockerfile ./Dockerfile.bak
    sed -i "1s/.*/FROM localhost:5000\/whanos-$techno:latest/" ./Dockerfile
}

# Function to build Docker image based on techno
build_docker_image() {
    local techno=$1
    local project_name=$2
    if [ -f "./Dockerfile" ]; then
        echo "Using base image"

        change_dockerfile "$techno"

        echo "Language of the project:"
        echo "$techno"

        docker build . -t whanos-project-$project_name
        echo "Successfully built whanos-project-$project_name"
    else
        echo "Using standalone image"
        docker build . -t whanos-project-$project_name -f /images/$techno/Dockerfile.standalone
    fi
}

# Function to deploy on Kubernetes
deploy_on_kubernetes() {
    if [ -f "./whanos.yml" ]; then
        echo "Deploying on Kubernetes"
        file_content=$(cat ./whanos.yml | base64 -w 0)
        echo $file_content
        curl -H "Content-Type: application/json" -X POST -d "{\"image\":\"localhost:5000/whanos-project-$1\",\"config\":\"$file_content\",\"name\":\"$1\"}" http://localhost:3030/deployments
    fi
}

echo "Starting Whanos"

# Check if there is a stored commit hash for the project
if [ -f "/usr/share/jenkins_hash/JENKINS_HASH_$1" ]; then
    git_commit_hash=$(cat "/usr/share/jenkins_hash/JENKINS_HASH_$1")
fi

# Compare the last stored commit hash with the latest commit in the repository
if [ "$git_commit_hash" != "$(get_latest_commit_hash)" ]; then
    echo "Changes occurred, containerization needed"
    techno=$(/var/jenkins_folder/findTech.sh .)

    # Check for an error while detecting the programming techno
    if [ $? -eq 1 ]; then
        echo "Error occurred getting techno"
        exit 1
    fi

    echo "Detected techno: $techno"

    # Build the Docker image based on the detected techno
    build_docker_image "$techno" "$1"

    # Tag, push, pull, and clean up the Docker image
    echo "Tagging $1"
    docker tag whanos-project-$1 localhost:5000/whanos-project-$1
    echo "Pushing"
    docker push localhost:5000/whanos-project-$1
    echo "Pulling"
    docker pull localhost:5000/whanos-project-$1
    #docker rmi whanos-project-$1

    # Deploy on Kubernetes if a configuration file exists
    deploy_on_kubernetes "$1"

    # Update the stored commit hash
    mkdir -p /usr/share/jenkins_hash
    get_latest_commit_hash > "/usr/share/jenkins_hash/JENKINS_HASH_$1"
else
    echo "No changes occurred"
fi
----
kubernetes/go.mod
module kube_binary_api_server

go 1.16

require (
	github.com/gin-gonic/gin v1.7.7
	github.com/go-playground/validator/v10 v10.9.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/mattn/go-isatty v0.0.14 // indirect
	github.com/ugorji/go v1.2.6 // indirect
	golang.org/x/crypto v0.0.0-20211202192323-5770296d904e // indirect
	golang.org/x/sys v0.0.0-20211205182925-97ca703d548d // indirect
	golang.org/x/text v0.3.7 // indirect
	google.golang.org/protobuf v1.27.1 // indirect
	k8s.io/api v0.22.4
	k8s.io/apimachinery v0.22.4
	k8s.io/client-go v0.22.4
	sigs.k8s.io/yaml v1.3.0
)

----
kubernetes/main.go
package main

import (
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"os/exec"
	"path/filepath"

	"github.com/gin-gonic/gin"
	appsv1 "k8s.io/api/apps/v1"
	apiv1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/homedir"
	"sigs.k8s.io/yaml"
)

type NewDeploymentInput struct {
	Image  string `json:"image"`
	Config string `json:"config"`
	Name   string `json:"name"`
}

type CustomResources struct {
	Limits   *apiv1.ResourceList `json:"limits,omitempty"`
	Requests *apiv1.ResourceList `json:"requests,omitempty"`
}

type CustomService struct {
	Type       string `yaml:"type,omitempty"`
	TargetPort int32  `yaml:"targetPort,omitempty"`
}

type CustomDeployment struct {
	Replicas  *int32           `yaml:"replicas,omitempty"`
	Resources *CustomResources `yaml:"resources,omitempty"`
	Ports     *[]int32         `yaml:"ports,omitempty"`
	Service   *CustomService   `yaml:"service,omitempty"`
}

type CustomConfig struct {
	Deployment CustomDeployment `yaml:"deployment"`
}

func GetconfigPath() string {
	if home := homedir.HomeDir(); home != "" {
		return filepath.Join(home, ".kube", "config")
	}
	return filepath.Join("/", ".kube", "config")
}

func NewKubernetesClient(kubeconfig string) *kubernetes.Clientset {
	config, err := clientcmd.BuildConfigFromFlags("", kubeconfig)
	if err != nil {
		panic(err.Error())
	}
	newKube, err := kubernetes.NewForConfig(config)
	if err != nil {
		panic(err.Error())
	}
	return newKube
}

func getConf(config string) (cfg CustomConfig) {
	if err := yaml.Unmarshal([]byte(config), &cfg); err != nil {
		panic(err)
	}
	return cfg
}

func main() {
	var kubeconfig = GetconfigPath()
	var newKube = NewKubernetesClient(kubeconfig)
	ClientsDep := newKube.AppsV1().Deployments(apiv1.NamespaceDefault)
	r := gin.Default()
	r.POST("/deployments", func(c *gin.Context) {
		var payload NewDeploymentInput
		if err := c.ShouldBindJSON(&payload); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{
				"error":       "malformed payload",
				"description": err.Error(),
			})
			return
		}
		value, err := base64.StdEncoding.DecodeString(payload.Config)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{
				"error":       "malformed payload",
				"description": err.Error(),
			})
		}
		var config = getConf(string(value))
		var ports = []apiv1.ContainerPort{}
		for idx := range *config.Deployment.Ports {
			ports = append(ports, apiv1.ContainerPort{
				ContainerPort: (*config.Deployment.Ports)[idx],
			})
		}

		c.JSON(http.StatusOK, gin.H{
			"status": "success",
		})

		println("Starting to pull image " + payload.Image)
		cmd := exec.Command("minikube", "cache", "add", payload.Image)
		cmd.Run()
		println("Finished pulling " + payload.Image)

		deployment := &appsv1.Deployment{
			ObjectMeta: metav1.ObjectMeta{
				Name: payload.Name,
			},
			Spec: appsv1.DeploymentSpec{
				Replicas: config.Deployment.Replicas,
				Selector: &metav1.LabelSelector{
					MatchLabels: map[string]string{
						"app": payload.Name,
					},
				},
				Template: apiv1.PodTemplateSpec{
					ObjectMeta: metav1.ObjectMeta{
						Labels: map[string]string{
							"app": payload.Name,
						},
					},
					Spec: apiv1.PodSpec{
						Containers: []apiv1.Container{
							{
								Name:  payload.Name,
								Image: payload.Image,
								Ports: ports,
								Resources: apiv1.ResourceRequirements{
									Limits:   *config.Deployment.Resources.Limits,
									Requests: *config.Deployment.Resources.Requests,
								},
								ImagePullPolicy: apiv1.PullNever,
							},
						},
					},
				},
			},
		}

		// Create the deployment
		result, err := ClientsDep.Create(context.TODO(), deployment, metav1.CreateOptions{})
		if err != nil {
			panic(err)
		}
		fmt.Printf("Created deployment %q.\n", result.GetObjectMeta().GetName())

		// Always create the service
		svc := &apiv1.Service{
			ObjectMeta: metav1.ObjectMeta{
				Name: payload.Name + "-service",
			},
			Spec: apiv1.ServiceSpec{
				Selector: map[string]string{
					"app": payload.Name,
				},
				Ports: []apiv1.ServicePort{
					{
						Protocol:   apiv1.ProtocolTCP,
						Port:       80,
						TargetPort: intstr.FromInt(int(3000)), // Assuming your app runs on port 3000
					},
				},
				Type: apiv1.ServiceTypeClusterIP,
			},
		}

		// Create the service
		_, err = newKube.CoreV1().Services(apiv1.NamespaceDefault).Create(context.TODO(), svc, metav1.CreateOptions{})
		if err != nil {
			panic(err)
		}
		fmt.Printf("Created service %q.\n", svc.GetObjectMeta().GetName())
	})
	r.Run(":3030")
}

----
stop.sh
#!/bin/bash

# Stop and remove the first two containers
docker ps -aq | head -n 2 | xargs -r docker rm -f

# Remove the Docker image with the specified repository and tag
docker rmi -f whanos-jenkins

#minikube stop

# Stop and remove a specific container
docker rm -f whanos-registry

# Remove Docker images with a specific repository and wildcard tag
docker images localhost:5000/whanos-project* -q | xargs -r docker rmi -f

# Kill processes using specific ports
fuser -k 8080/tcp
fuser -k 3030/tcp

----
test

--END--
